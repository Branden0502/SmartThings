/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
/**
 * Add and remove user codes for locks
 *
 * Copyright RBoy
 * Redistribution of any changes or code is not allowed without permission
 *
 * Change Log:
 * 2015-7-6 - Fixed issue with code expiry not working
 * 2015-6-18 - Added option to change delay between sending codes for users who have issues with communications
 * 2015-6-18 - Added notification for jammed door locks
 * 2015-6-17 - Fix for dynamic preferences not working after ST platform update
 * 2015-6-9 - Added support to disable push notifications only
 * 2015-5-27 - Added support for expiration dates
 * 2015-2-20 - Fixed issue with SMS not being sent
 * 2015-1-9 - Improve reliability with coding
 * 2015-1-1 - Created
 *
 */
definition(
		name: "Lock multi user code management with notifications",
		namespace: "rboy",
		author: "RBoy",
		description: "Add and Delete Multiple User Codes for Locks with code use notifications",
		category: "Safety & Security",
		iconUrl: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave.png",
		iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave@2x.png"
	  )

import groovy.json.JsonSlurper

preferences {
	page(name: "setupApp")
    page(name: "usersPage")
}

def setupApp() {
    dynamicPage(name: "setupApp", title: "Lock User Management", install: false, uninstall: true, nextPage: "usersPage") {    
        section("Select Lock(s)") {
            input "locks","capability.lock", title: "Lock", multiple: true
        }

		section("How many Users do you want to manage (common to all selected locks)?") {
        	input name: "maxUserNames", title: "Max users", type: "number", required: true, multiple: false,  submitOnChange: true
        }
        		
		section([mobileOnly:true]) {
			label title: "Assign a name for this SmartApp", required: false
		}

		section("Code Programming Option (optional)") {
            paragraph "Change this setting if all the user codes aren't being programmed on the lock correctly. This settings determines the time gap between sending each user code to the lock. If the codes are sent too fast, they may fail to be set properly."
            input name: "sendDelay", title: "Delay between codes (seconds):", type: "number", defaultValue: "15", required: false
        }
    }
}

def usersPage() {
	dynamicPage(name:"usersPage", title: "User Names, Codes and Notification Setup", uninstall: true, install: true) {

	section("Notification Options") {
        input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
        paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app. This does not impact the SMS notifications."
        input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
    }
	
    section("Jammed Lock") {
    	input name: "jamNotify", title: "Notify on Lock Jam/Stuck", type: "bool"
    }

    section("Manual Unlock") {
    	input name: "manualNotify", title: "Notify on Manual Unlock", type: "bool"
    }

	for (int i = 1; i <= settings.maxUserNames; i++) {
            def priorName = settings."userNames${i}"
            def priorCode = settings."userCodes${i}"
            def priorNotify = settings."userNotify${i}"
            def priorExpireDate = settings."userExpireDate${i}"
            def priorExpireTime = settings."userExpireTime${i}"
        	def invalidDate = true
            log.debug "Initial $i Name: $priorName, Code: $priorCode, Notify: $priorNotify, ExpireDate: $priorExpireDate, ExpireTime: $priorExpireTime"
        	if (priorExpireDate) {
            	log.debug "Found expiry date in setup"
            	try {
                	Date.parse("yyyy-MM-dd", priorExpireDate)
                    invalidDate = false
                }
                catch (Exception e) {
                	log.debug "Invalid expiry date in setup"
                    invalidDate = true
                }
            }

            section("User Management Slot #${i}") {
                if (priorExpireDate && invalidDate == true) {
                    paragraph "INVALID DATE - PLEASE CHECK YOUR DATE FORMAT"
                } else if (priorExpireDate) {
                    def ed = Date.parse("yyyy-MM-dd", priorExpireDate)
                    paragraph "Code expiry date set for ${ed.format("EEE MMM dd yyyy")}"
                }

                if (priorExpireDate) {
                    if (!priorExpireTime) {
                        paragraph "PLEASE ENTER TIME FOR CODE EXPIRY"
                    }
                }

				if (priorCode) {
                    input name: "userNames${i}", description: "${priorName}", title: "Name", defaultValue: "${priorName}", type: "text", multiple: false, required: false
                    input name: "userCodes${i}", description: "${priorCode}", title: "Code", defaultValue: "${priorCode}", type: "text", multiple: false, required: false
                    input name: "userNotify${i}", title: "Notify", defaultValue: "${priorNotify}", type: "bool"
                } else {
                    input name: "userNames${i}", description: "Tap to set", title: "Name", type: "text", multiple: false, required: false
                    input name: "userCodes${i}", description: "Tap to set", title: "Code", type: "text", multiple: false, required: false
                    input name: "userNotify${i}", title: "Notify", type: "bool"
                }
                
                if (priorExpireDate) {
                    input name: "userExpireDate${i}", title: "Code expiration date (YYYY-MM-DD) (optional)", description: "Date on which the code should be deleted",  defaultValue: "${priorExpireDate}", type: "date", required: false,  submitOnChange: true
                } else {
                    input name: "userExpireDate${i}", title: "Code expiration date (YYYY-MM-DD) (optional)", description: "Date on which the code should be deleted", type: "date", required: false,  submitOnChange: true
                }
                
                if (priorExpireTime) {
                    input name: "userExpireTime${i}", title: "Code expiration time (optional)", description: "(Touch here to set time) The code would be deleted within 5 minutes of this time", defaultValue: "${priorExpireTime}", type: "time", required: false,  submitOnChange: true
                } else {
                    input name: "userExpireTime${i}", title: "Code expiration time (optional)", description: "(Touch here to set time) The code would be deleted within 5 minutes of this time", type: "time", required: false,  submitOnChange: true
                }
            }
        } 
	} 
}

def installed()
{
	log.debug "Install Settings: $settings"
	runIn(1, appTouch)
}

def updated()
{
	log.debug "Update Settings: $settings"
	runIn(1, appTouch)
}

def doorHandler(evt)
{
	def data = []

	log.debug "Event name $evt.name, value $evt.value, device $evt.displayName, data $evt.data"
    
	if (evt.name == "lock") {
    	if (evt.value == "unlocked") {
            def isManual = false
	    	if ((evt.data == "") || (evt.data == null)) {  				// No extended data, must be a manual/keyed unlock
            	isManual = true
            }
            else {														// We have extended data, should be a coded unlock           	
	    		data = new JsonSlurper().parseText(evt.data) 
            	if ((data.usedCode == "") || (data.usedCode == null)) {	// If no usedCode data, treat as manual unlock
                	log.debug "Unknown extended data (${data}), treating as manual unlock"
                	isManual = true
           		 }
            }
            
            if (isManual) {
            	log.debug "$evt.displayName was unlocked manually"
                if (manualNotify) {
                    if (!disableAllNotify) {
                    	sendPush "$evt.displayName was unlocked manually"
                    }
                    if (sms) {
                        sendSms(sms, "$evt.displayName was unlocked manually")
                    }
                    return
                }
            }
            else {
            	Integer i = data.usedCode as Integer
                def userName = settings."userNames${i}"
                def notify = settings."userNotify${i}"
                
                log.debug "Lock $evt.displayName unlocked by $userName, notify $notify"
                if (notify) {
                    if (userName == null) {
                    	if (!disableAllNotify) {
                        	sendPush "$evt.displayName was unlocked by Unknown User"
                        }
                        if (sms) {
                        	sendSms(sms, "$evt.displayName was unlocked by Unknown User")
                        }
                    }
                    else {
                    	if (!disableAllNotify) {
                        	sendPush "$evt.displayName was unlocked by $userName"
                        }
                        if (sms) {
                        	sendSms(sms, "$evt.displayName was unlocked by $userName")
                        }
                    }
                }
            }
        }
        else if (evt.value == "jammed") {
            log.debug "Lock $evt.displayName Jammed!"
            if (notify) {
                if (!disableAllNotify) {
                    sendPush "$evt.displayName lock is Jammed!"
                }
                if (sms) {
                    sendSms(sms, "$evt.displayName lock is Jammed!")
                }
            }        	
        }
    }
}
                
def appTouch() {
	unschedule() // clear all pending updates
    unsubscribe()
    runEvery5Minutes(expireCodeCheck)
    subscribe(locks, "lock", doorHandler)
    
    if (!state.codes) {
    	state.codes = [:]
    }

    state.lockList = []

	for (lock in locks) {
    	state.lockList.add(lock.id) // reset the state for each lock to be processed
        log.debug "Adding $lock id ${lock.id} to unprocessed locks list ${state.lockList}"
    }
    state.nextCode = 1 // set next code to be set
    
    runIn(1, updateCodes) // Updates codes
    
    log.debug "Scheduling code updates starting with code $state.nextCode in 1 second"
}

def updateCodes() {
	for (lock in locks) {
		if (state.lockList.contains(lock.id)) { // this lock codes hasn't been completely initiated
        	log.debug "Check for pending code updates for $lock"
	        if (state.nextCode <= settings.maxUserNames) {
            	log.debug "Updating code $state.nextCode on $lock"
                def name = settings."userNames${state.nextCode}" // Get the name for the slot
                def code = settings."userCodes${state.nextCode}" // Get the code for the slot
                def expDate = settings."userExpireDate${state.nextCode}" // Get the expiration date
                def expTime = settings."userExpireTime${state.nextCode}" // Get the expiration time
                def user = state.nextCode // which user slot are we using

                if (code != null) { // We have a code, update or set the code in the slot
                    lock.setCode(user, code)
                    log.info "$lock added user: $user, code: $code, name: $name"
                    sendNotificationEvent("$lock added $name to user $user")
                } else { // No code, delete the slot
                    lock.deleteCode(user)
                    log.info "$lock deleted user: $user"
                    sendNotificationEvent("$lock deleted user: $user")
                }
                
                // Set the code expiration if required
                if (expDate && expTime) {
                    def midnightToday = timeToday("2000-01-01T00:00:00.000-0000", location.timeZone)
                    def expT = (timeToday(expTime, location.timeZone).time - midnightToday.time)
                    String dst = location.timeZone.getDisplayName(location.timeZone.inDaylightTime(new Date(now())), TimeZone.SHORT) // Keep current timezone
                    def expD = Date.parse("yyyy-MM-dd Z", expDate + " " + dst).toCalendar()
                    def exp = expD.getTimeInMillis() + expT
                    log.debug "Removing any existing tracking expiry of user $user"
                    state.codes.remove((user as String)) // remove it from the tracker so we don't duplicate if the code being overwritten
                    state.codes.put(user,exp) // Add to the expiry list
                    def expStr = (new Date(exp)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                    log.info "$lock user code expiration set to $expStr"
                    sendNotificationEvent("$lock user $user code will expire on $expStr")
                }

				state.nextCode = state.nextCode + 1 // move onto the next code

				log.debug "Scheduled next code update in ${sendDelay > 0 ? sendDelay : 15} seconds"
                startTimer((sendDelay > 0 ? sendDelay : 15), updateCodes) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                return
            }
            
            state.lockList.remove(lock.id) // we are done with this lock
            state.nextCode = 1 // reset back to 1 for the next lock
            log.debug "$lock id $lock.id code updates complete, unprocessed locks ${state.lockList}, reset next code update to $state.nextCode"
        }
    }
}

def expireCodeCheck() {
	log.debug "ExpireCodeCheck called"
    def allCodes = state.codes.collect() // make a copy otherwise we can't remove it from the for loop (concurrent exception)
	for (code in allCodes) {
        def expStr = (new Date(code.value)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
        log.debug "user ${code.key} expires $expStr"
		if (code.value < now()) {
        	def user = code.key as Integer // Convert back to integer, groovy converts to string in a key value pair
            for (lock in locks) {
                lock.deleteCode(user)
                log.info "$lock deleted expired user: $user"
                sendNotificationEvent("$lock deleted expired user: $user")
	        }
            log.debug "Removing tracking of user $user"
            state.codes.remove((user as String)) // remove it from the tracker, we're done here
        }
    }
}

def startTimer(seconds, function) {
	def runTime = new Date(now() + (seconds * 1000))
	runOnce(runTime, function, [overwrite: false]) // runIn isn't reliable, use runOnce instead, don't overwrite existing function calls pending
}